### SwiftUI
---

1. 2019 WWDC에서 발표되어 현재는 4.0 버전을 지원한다.
- 2.0 부터 UIKit을 대신할 수 있다는 공언이 있었으나, 당시에는 설득력이 없다고 여겨졌고 현재는 스유의 패러다임이 오고있다고 믿는 세태.
- 앱 개발을 더 빠르고 쉽게하고 개발 중 발생하는 버그를 줄이기 위해 등장했다.
    + UIKit을 대신해서 Swift를 위한 UI로 자리매김하고자 한 의도도 있는 듯.
    + UIKit을 허물고 완전히 새 판을 짰기 때문에, 이번 앱스쿨에서는 스유를 집중적으로 하는 방향을 채택한 것으로 보이네.
    
2. UIKit vs SwiftUI
- 유킷의 단점 :
    + IB에서 단순 XIB가 Storyboard로 확장되면서 재사용의 문제가 생긴다.
    + 수작업 연결, 뷰 뒤의 숨은 뷰를 설정하기 어렵다는 점과 애니메이션 대응에 준비되지 않음
    + 결국 코드로 직접 화면을 만지게 되는데 코드가 복잡해지고 까다로운 Autolayout 때문에 IB 구성에 실수가 생긴다.
    + 시간도 많이 들고, 오류도 많고, 알아보기도 어렵고, 생산성도 떨어진다.
- 스유의 장점 : "스위프트" 를 바탕으로 오로지 스위프트만을 위한 프레임워크라는 것만으로도 굉장한 장점이다.
    + Live Preview
        * 실시간 레이아웃 변경, 테스트까지 가능
    + 선언구문 : 적은 양의 코드로 명확한 UI 구성 가능 
    + 데이터 주도 개발 : 데이터의 변화가 뷰에 그대로 반영되는데, 개발자가 직접 구현하지 않아도 대부분의 작업을 처리해줌
        * MVVM 아키텍쳐를 애플이 직접 지정해서 사용하라고 한 적은 없다고한다.
    + 우수한 앱을 더 적은 코드로 만들 수 있고 모든 애플 플랫폼에 재활용이 가능하다.
    + 디자인 도구를 잘 지원한다.
    
---
### 선언 구문

- objc 기반의 UIKit 은 명령형 구문에 기반하여 코딩해야 했다.
- 명령형 구문은 '어떻게'에 집중해서 코딩한다.
    + 강남역 2호선에서 교대역 횡단보도까지 1.02km 이동
    + 베라 교대역으로 횡단
    + 스벅 교대역점까지 345m 이동
    + 롯데하이마트 교대역점으로 횡단
    + 교대역까지 44m 이동

- 선언형 구문 : 누군가가 작성한 코드의 힘을 빌려 '목적만 이룬다'. 즉 **어떤 것**을 이룰지에 집중한다.
    + 강남역에서 교대역까지 도보로 이동
- 별도 레이아웃 설계 도구와 스토리보드, XIB 등에 의존적이지 않다.
    + 화면 컴포넌트의 레이아웃과 모양에 대한 세부를 직접 설계하는 시간을 절약 가능
    + 컴포넌트에 포함될 레이아웃 매니저 종류를 명시한다.
        * VStack, HStack, ZStack, Form, List ...
        * 속성을 설정하기 위한 modifier를 사용한다.
        * 복잡한 세부 사항은 SwiftUI의 내부 코드에서 처리한다(레이아웃 위치, 강제사항, 렌더링 등등).
- 단순하고 직곽적인 구문으로 화면 설계 가능
    + 실제 구축 방식의 복잡함은 고려할 필요가 없다.
    + UI의 모양은 코드로 선언하여 레이아웃을 생성한다.
    + 스유의 UI선언은 계층적으로 이뤄진다.
    + 작고 재사용 가능한 View를 사용자 정의 - 모듈화해서 반복하여 사용할 수 있다.
    
---
### 데이터 주도

- UIKit과 MVC(모델-뷰-컨트롤러) : UI, Data, Logic 구현에 자주 사용되는 소프트웨어 디자인 패턴
    + 아주 러프하게 언급하자면, 반복되는 문제를 해결하기 위해 아키텍쳐가 등장했다.
    + 로직과 UI를 구분하는 데에 중점을 둔다.
    + 모델 : 데이터와 비즈니스 로직 관리
    + 뷰 : 레이아웃과 화면을 처리
        * 뷰와 뷰컨이 뒤섞이는 현상이 UIKit에서는 자주 보였다.
    + 컨트롤러 : 명령을 모델과 뷰로 라우팅
- MVVM : MVC 에서 각 객체가 자주 섞이는 현상을 어느정도 극복하기 위해 등장
    + ViewModel : View의 추상화 계층으로서 뷰와 직접적인 관계를 맺지 않는 상태에서 Notify만 한다.
        * 등록된 뷰는 Notify를 확인하고 스스로 결과를 반영해서 UI에 반영한다.
        * 즉, 뷰를 참조할 필요가 없다.
    + RxSwift : UI이벤트 중심의 클로저 활용으로 코드 단순화
        * 바인딩 데이터를 변경할 때 화면 요소가 자동으로 갱신된다.
        * 강사 설명에 따르면 쓰지 않는다고 한다..?
        * 스유의 등장으로, UIKit을 보조하기 위한 프레임워크들은 자연스럽게 점유율이 떨어지는듯
- 데이터주도 : Data와 UI, Logic 의 관계에서 등장하는 '데이터 주도'
    + UIKit은 앱 데이터를 살피기 위해 직접 코드를 작성해야 했고, 화면에 반영하고 데이터의 변화를 감시할 코드를 직접 써야 했다.
    + SwiftUI는 앱 데이터 모델과, UI, Logic을 바인딩해서 여러 방법으로 복잡도를 낮출 수 있었다.
    + 앱이 다른 부분에서 Subscribe할 수 있는 데이터 변수를 Publish하도록 하기 때문에 데이터 변경이 구독자에게 곧바로 전달된다.
    + UI와 모델이 바인딩되면, 추가 코드 없이 모든 데이터 변경 사항이 SwiftUI에 의해 UI에 자동 반영되는 것.
- 이제부터는 xcode로 진행이 될 것 같다!
---