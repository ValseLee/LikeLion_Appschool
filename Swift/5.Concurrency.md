### 동시성 프로그래밍

1. 여러 개의 쓰레드와 코어는 여러 가지의 일을 업무를 진행할 수 있도록 설계되어 있다.
2. 쓰레드와 코어는 iOS 운영체제가 업무를 분배해주며, 개발자는 업무를 어떻게 분배할지만 고민하면 된다.
3. Swift는 iOS 13.0 버전 이후로 `Asnyc`, `Await` 를 지원한다.
    - 기존에도 동시성 프로그래밍은 가능했으나, 피라미드 코드, 컴플리션의 지옥에 빠지곤 했다.
    
---
### 추가 정리
UIKit 은 기존에 이스케이핑 클로저를 활용해서 비동기적으로 작동하는 메소드와 함수를 관리할 수 있었다.
이 클로저는 throw되지 않고 실패할 때에도 매번 컴플리션 핸들러가 호출해야 한다.
물론 컴플리션 핸들러로 구현 자체는 가능한데... 너무 알아보기 어려운 코드가 되고 안전한 코드도 아니다.
이를 보강하기 위해 결과 타입(Result Type)가 도입되었는데, 이것도 사실 미봉책에 불과했다.
단순하고 쉽고 안전하게 Async, Await를 써보자.

---
### Async/Await

Swift5.5 에 도달하면서 Async하게 작동하는 Throws 타입인 함수를 정의할 수 있게 되었다.
에러가 일어나면 `throw` 하고, 아니면 결과 자체를 한 번에 리턴할 수 있다.
`.date(from: URLRequest)` 메소드는 실패할 수 있기 때문에 `try`로 호출하며, 비동기적으로 작동할 수 있도록 `await` 키워드와 함께 호출된다.
`async` 함수를 호출할 때에는 `await` 키워드를 붙이며, 이 키워드는 한 번만 써도 된다(내부의 async 키워드가 등장하는 숫자와 무관하다).

에러가 리턴된다면 throw 되고, do catch로 핸들링 하면 된다.
그게 아니라면 `(data, response)` 가 튜플로 리턴된다.
매우매우 단순하고 명료한 코드가 리턴된다.

`await` 함수가 리턴되기 전까지 쓰레드는 다른 일을 할 수 있다.
실패하더라도 컴플리션 핸들러는 호출할 필요가 없으며 do-catch 에서 에러 핸들링이 가능하다.

- 메소드뿐 아니라 생성자와 속성도 Async 할 수 있다.

```swift
extension UIImage {
    var thumbnail: UIImage? {
    get async {
            let size = CGSize(width: 40, height: 40)
            return await self.byPreparingThumbnail(ofSize: size)
        }
     }
}

```
---

`await`은 루프할 수도 있다.
결과가 나오기 전까지 쓰레드는 다른 일을 할 수 있다!
```swift
await works in for loops
```
---
### suspend

async 함수가 유예될 수 있다(Suspend될 수 있다)는 것은 무엇을 의미하는가?
일반함수라면 리턴값이 나오기 전까지 sync하게 작동한다.
그 이후 다시 제어권을 넘기는 것이다.

async 함수는 제어권을 System에 넘긴다.
그래서 함수 자체의 실행은 멈출 수 있고 System은 우선순위에 따라 다른 함수를 쓰레드에서 작업할 수 있다.
이 과정은 여러 차례 반복될 수 있다.
그런데 async라고 해서 꼭 이런 과정을 겪는 것은 아니다.

1. async는 함수와 그 함수의 호출자가 suspend 될 수 있음을 의미
2. 그 suspension 동안 다른 작업이 가능하다.
3. 이 Suspend 지점을 찾아주는 키워드가 `await` 이다!
4. 그래서 작업이 끝나면 이곳에서 다시 함수가 진행된다.

