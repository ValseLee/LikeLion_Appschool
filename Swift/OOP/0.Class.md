### 객체 지향 프로그래밍
---

0. 들어가기전) 스위프트의 모든 타입에 대해
- 타입은 모두 셋 중 하나.
    + 구조체 : 값 형식의 타입. 대부분의 기본 타입(정수, 실수, 문자열)은 **구조체**에 속한다.
    + 열거형 : 
    + 클래스 : 참조 형식 타입. 객체 지향 언어에서 가장 많이 쓰이는 개념 및 용어. 클래스를 학습한 후 그외 타입을 학습하며 차이를 비교해보자.
    
1. 클래스(class)
- 세상의 모든 것을 객체라고 가정하자. 이 객체들은 서로 상호작용하는데 이 작용으로 프로그램이 동작한다. 각 객체는 하나의 역할을 수행하는 메서드와 데이터의 묶음을 갖고 있다.
- 객체 '언어'는 그 자체로 절차 지향을 언어를 **지양**한다. 객체 언어는 말 그대로 모든 것이 객체이기 때문.
- 기본적으로 스위프트는 절차 지향적이지만 객체 지향의 태도를 적용하고 있다.
- 기능은 **속성**, 동작은 **메소드**라 부른다.
    + 클래스 내에서만 정의된 변수 및 함수이다.
    + 클래스를 정의한 후에, 그 내부의 메소드나 속성을 호출하고 싶다면 **초기화**를 해야 한다.
- **클래스는 객체가 어떻게 생성되어야 할지를 정의한다.**

2. 객체 자세히 보기
- 객체(인스턴스)는 소프트웨어 앱을 구축하는 블록으로 쉽게 사용하고 재사용 가능한 독립 기능 모듈이다.
    + 적어도 스위프트에서는 클래스 인스턴스만이 객체다.
- 작업 수행을 위한 객체나 인스턴스에 접근하여 속성, 메소드를 호출할 수 있다.
- 객체를 구성하는 이러한 데이터 변수와 함수를 포괄하여 **클래스 멤버**라고 부른다.

3. 클래스와 객체 선언하기
- 객체를 인스턴스화 하기 전에 먼저 객체에 대한 청사진=클래스를 정의해야 한다.
- 클래스를 새로 선언할 때는 어떤 부모 클래스에서 파생되었는지 지정할 수 있으며, 그 내부에 속성과 메소드를 정의할 수 있다.
    + 속성 : 클래스 내에 포함될 변수, 상수를 정의한다.
    + 메소드 : 클래스에서 호출될 함수를 정의하며, 본질적으로는 클래스의 고유 함수가 된다. 그래서 함수가 메소드보다 범위가 넓다.
- 왜 이런 짓을 하는가? : **데이터 캡슐화**를 위해.
    + 클래스에 저장되고 접근할 수 있는 데이터는 그 클래스 내에 정의된 메소드를 통해야만 한다.
    + 캡슐화된 데이터가 속성, 인스턴스 변수가 된다.
    + 만약 인스턴스를 생성하지 않고 클래스 자체에서 특정 동작을 수행하고 싶다면 `class func` 키워드를 사용할 수 있다.
        * [`class vs static`](https://stackoverflow.com/questions/29636633/static-vs-class-functions-variables-in-swift-classes)
- **초기화** : 인스턴스 참조체를 저장할 변수를 선언하기 위해서 전처리를 해야 하는데, 이 과정을 초기화(`Initialize`)라 할 수 있다.
    + 생성 시점에 초기화 작업이 있을 수 있고 클래스 내부의 `init` 메소드에 구현된다.
    + 새로운 클래스 인스턴스가 생성될 때에, 클래스의 각 속성을 초기화한다.
    + 반대로 클래스 인스턴스가 사라지면서 해야 할 메모리 정리 작업 등은 `deinit`에서 구현할 수 있다.

```swift
class BankAccount {
    var owner: String = ""
    var accountBalance: Float = 0
    var accountNumber: Int = 0

    func displayBalance() {
        print("Number : \(accountNumber)")
        print("Current Balance : \(accountBalance)")
    }

    class func getMaxBalance() -> Float {
        return 100000.00
    }

    init(owner: String, balance: Float, number: Int) {
        self.owner = owner
        self.accountBalance = balance
        self.accountNumber = number
    }
}

// 인스턴스 선언
let account1: BankAccount = BankAccount(owner: "승준", balance: 100000.00, number: 1010101)
```

4. 메소드에 접근하고 호출하기
- 클래스를 만들고, 프로퍼티와 메소드를 선언했다.
- 그렇다면 클래스 내부의 속성과 메소드는 어떻게 호출할 수 있을까?
- 점 표기법 : 클래스 인스턴스에 점을 찍어 프로퍼티, 메소드 이름을 써서 그 인스턴스가 갖고 있는 클래스의 변수, 메소드를 호출할 수 있다.
`var balance = account1.accountbalance`
    + 접근범위나 기타 제반사항이 맞아떨어진다면 클래스 내부의 속성에 직접 값을 할당할 수 있다.
    + 타입 메소드도 점 표기법으로 호출할 수 있으나, 클래스 타입 자체에 접근해서 호출해야 한다.

5. 속성의 종류들
- 저장 속성 : 상수, 변수에 담기는 값, 위의 예시는 모두 저장 속성이다.
    + 클로저를 활용해서 초기화할 수 있으며, 경우에 따라 **지연 저장 속성**으로 선언할 수 있다.
- 연산 속성 : 프로퍼티에 값을 설정하거나 가져오 시점에 계산, 로직에 따라 처리된 값이다.
    + getter(필수), setter(선택) 메소드를 생성해서 연산 수행 코드를 갖는다.
    + 값에 대한 호출 요청이 있을 때마다 메소드를 실행한다.
    + 수수료를 계산해서 현재의 잔액을 구하거나 새로운 값을 할당 할 때는 이렇게 구현한다.
    + 새로 선언한 세터는 수수료를 뺀 값을 위에 있는 저장 프로티에 할당한다.
```swift
extension BankAccount {
    let fees: Float = {
        return 25.00
    }()

    var balanceLessFees: Float {
        get {
            return accountBalance - fees
        }

        set(newBalance) {
            accountBalance = newBalance - fees
        }
    }
}
```
- 지연 저장 속성 : `lazy` 키워드로 선언할 수 있다. 속성의 초기값을 설정하는 여러 방법 중 하나이다.
    + 여러 저장 속성을 모두 클로저로 초기화해버리면 연산 규모에 따라 매우 오랜 시간이 걸릴 수 있다.
    + 그래서 각 인스턴스에 실제로 접근이 일어나는 시점에 초기화하고 싶다면 각 인스턴스의 초기화 시점을 분류하는 동시에 클로저 로직도 비교적 부담없이 구성할 수 있다.
    + 이를 위해 지연 저장 속성을 활용한다.
6. `self` : 현 클래스 인스턴스에 속한 메소드나 속성을 가리킬 때 사용하는 `self` 키워드.
- 대부분의 상황에서는 컴파일러가 이미 속성과 메소드 참조를 디폴트로 간주하고 있기에 명시할 일이 없다.
    + 특정 메소드의 파라미터와 속성의 이름이 동일하다거나 클로저를 사용하고 있을 경우에 주로 쓰게 된다.
    + 물론 개발자 취향에 따라 쓰는 빈도를 정할 수는 있곘으나 필수는 아니라는 점.