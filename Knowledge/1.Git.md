### Git과 버전관리
---

0. DevOps?
- 이전까지는 Waterfall 방식으로 업무가 이뤄졌다.
    + 기획 -> 디자인 -> 개발 -> 테스트 -> 출시
    + 이전 단계를 다 끝내야 다음 단계로 넘어가던 업무 프로세스
- Design Thinking : 더 나은 방법으로 업무 프로세스를 개선할 수 없을까?
    + 공감 -> 문제정의 -> 아이디에이션 -> 프로토타입 -> 테스트 -> 반복
    + 반복적 피드백과 시도를 통한 개선
    + 개발 주기를 짧게 가져가는 애자일 프로세스와 관계가 깊다.
    

1. Agile Process : 최종 목표보다 시장의 변화에 중점을 두고 유동적으로 따라가기
    + 구현과 유지 보수를 위해 큰 단위의 업무를 작은 단위로 구별해서 업무에 집중하는 스프린트(**Sprint**)의 연속
        * 로그인 프로세스만 하자 -> 회원가입 프로세스만 하자 -> ... -> 완성? -> 로그인 프로세스 개선하자 -> ...
    + 반복적이고 점진적인 접근 방식을 바탕으로 신속한 변화를 위해 필요한 변경이나 반복을 수행하는 자유롭고 유연한 방식
    + 사용자의 요구사항을 프로젝트의 모든 단계에서 변경할 수 있기 때문에 계획의 수립에 투입하는 리소스를 최소화할 수 있다.
        * 즉, **사용자의 지속적 피드백으로 프로젝트 자체가 성장하는 것을 전제로 한다**.
    + 개발 팀은 시간에 따른 반복 작업을 수행하는 기능 단위로 구성되며, 각 반복 작업은 작동 가능한 제품을 생산하게 된다.
    + **리더는 신속한 변화에 감응해서 이해관계자와의 팀워크와 대면 상호작용을 촉진하고, 최종 사용자의 요구를 충족하고자 리더쉽을 발휘하게 된다**.
    + 더욱 자세한 방법론은 Agile Manifesto를 참고.
        * 개인과의 상호작용, 작동 가능한 소프트웨어, 고객과의 협력 및 피드백, 변화에 대응하는 것이 핵심 골자.
        * 개발 관련한 모든 제안과 기능은 한 장으로 짧게 설명되어야 한다. 직관적으로 머릿속에 설계가 잡혀야 협업이 유연하게 할 수 있다.
- Agile의 장점 
    + 변화 요구사항을 수용하기 쉬움
    + 최종 목표가 불확실한 프로젝트에 용이
    + 보다 빠르게 고품질 제공 가능
    + 강력한 팀 상호 작용
    + 사용자 피드백 수용에 용이
- Agile의 단점
    + 계획의 불확실성 : 릴리스로 예약된 일부 항목이 완료가 제때 이루어지지 않을 수 있다.
    + **팀 구성의 어려움** : 팀이 대체로 작기 때문에 팀 구성원을 구성하면어 다양한 분야에서 높은 수준의 기술을 보유하고 있어야 한다. TF로 구성된다고 보면 좋다.
    + 비포괄적인 설명
    + 최종 제품이 요구사항과 다를 수 있음 : 유연함이 가져오는 단점 중 하나일 수 있다. 고객 피드백에 많은 것을 의존하기 때문에 작업의 추가와 개선이 최종 제품의 변화를 가져올 수 있다.
    
2. 다시, 데브옵스 : Dev + Operations(배포와 문제해결 중심의 운영)
- 앱과 서비스를 **빠르게 제공**할 수 있도록 조직 역량을 향상시키는 문화 철학 방식 도구의 조합을 의미한다.
- 기존 소프트웨어 개발, 인프라 관리 프로세스를 사용하는 조직보다 제품을 빠르게 혁신하고 개선할 수 있다.
- 빠른 속도를 통해 조직은 고객을 더 잘 지원하고 시장에서 효과적으로 경쟁할 수 있다.
    + 자동으로 앱 테스트 -> 배포 및 대응할 수 있도록 개발 제반 사항을 지원하는 것이 데브옵스의 경향
- 데브옵스의 장점
    + 속도 : 작업속도가 빠르기 위해 혁신의 속도와 시장 변화 적응이 유연하다.
    + 제공 : 릴리스 빈도와 속도 개선으로 빠른 혁신이 가능하다.
    + 안정성 : 위의 두 가지 장점이 빠르게 제공되면서 더 안정적인 앱 제공이 가능하다.
    + 확장 : 규모에 따라 개발 프로세스를 운영 및 관리할 수 있기 때문에 자동화와 일관성이 보장된다. 복잡한 시스템이나 변화 시스템의 효율적 관리 가능
    + 협업 중심 : 주인의식과 책임을 중심으로 효과적인 팀을 구축하여 개발-운영 팀의 협력, 워크플로를 결합하여 비효율성을 줄이고 시간 절약 가능
    + 보안 : 제어 유지, 규정 준수, 신속 진행 -> 자동화된 규정 준수 정책으로 세분화된 제어 및 구성 관리 기술 사용

- 다양한 데브옵스 도구들이 있다.
    + 깃허브 액션 : 위의 데브옵스를 지원하기 위한 자동화 워크플로(테스트와 배포가 가능)
    + Xcode Cloud : 애플의 클라우드 서버가 iOS 코드를 커밋 푸쉬를 체크하여 테스트하고 앱스토어에 배포
    + 이 모든 기능들은 Git과의 연동 속에서 사용된다. 평생 혼자 개발할 거라면 굳이 깃 안해도 되겠지.
    + Git의 중요성은 데브옵스와의 시너지 때문에 계속해서 두각될 것.
    
3. 버전 관리 시스템(Version Control System)
- 사용자 프로젝트의 파일 변경 사항을 추적할 수 있도록 돕는 방법론이나 도구
    + 작업 파일의 복사본을 두고 이름 뒤에 사용자가 스스로 시간을 더하는 방식이 제일 단순한 방법(_진짜최종.jpg)
- 분산 버전 관리 시스템(Distributed Version Control System, DVCS)
    + 분산 환경의 협업을 위한 버전 관리 시스템. 개발자가 중앙 서버에 접속하지 않아도 코드 작업이 가능하다.
        * CVS, SVN, Mercurial, `Git`
- 형상 관리(Configuration Management, CM) : 앱의 여러 버전에서 서로 다른 구성을 다루는 도구
    + 버전 관리 시스템을 기반으로 구축되지만, CM 자체가 버전 관리를 해주진 않는다.

4. `Git`
- Linus Torvalds에 의해 2005년 제작된 분산 버전 관리 시스템
    + 본인이 리눅스 커널 코드 관리하다가 답답해서 2주 동안 뚝딱 했다고 한다.
- 깃의 장점 :
    + 작고 빠르다. 서버와 통신할 필요도 없이 로컬에서 작업이 이루어진다.
    + 분산 버전 관리 시스템이기 때문에 로컬에 원격 저장소의 모든 데이터를 복제할 수 있다. 저장소를 여러 개 만들 수 있고 작업방식에도 자유도가 있다.
    + 데이터의 무결성을 보장한다. 파일과 커밋을 검사하고 히스토리 변경에 대해 커밋 ID와 모든 항목의 커밋ID를 변경하게 된다. 즉, 특정 커밋은 ID만으로는 변경할 수 없다.
    + 커밋 이전 스테이징, 인덱스 상태를 가지며 커밋 내역을 검토하며 일부 커밋, 일부 언스테이지 등이 가능하다.
    + GNU 퍼블릭 라이선스로 모두에게 무료다!
- 단점 : 
    + 조금 어렵고 직관성이 떨어진다.
    + 터미널 명령어에 많이 의존하는 편이다.
    + 그러나 여러 GUI 앱과 도구가 새롭게 많이 나오는 중이다.
    + 디렉토리나 파일별 권한 부여가 불가능(SVN은 가능함)
- 깃의 흐름
    + `init`, `clone` : 내 로컬 공간에 깃 작업 디렉토리 생성(.git 폴더).
    + 작업 디렉토리 내에 코드 작성(Untracked Files, Unstaged Files)
    + `add` : 스테이징
    + `commit` : 커밋 메세지와 함께 해쉬값 생성 -> 세이브 포인트 저장.

5. `GitHub`
- 2008년 설립된 대표적인 무료 Git 저장소, 2016년 MS가 75억 달러로 인수했다.
- 주요 개념 
    + repsoitory : Git 으로 버전을 관리하는 디렉토리
        * 사용자의 변경 내용을 모두 추적한다.
        * 현재 상태, 변경 시기, 변경자, 변경 관련 텍스트 로그 메시지
    + local : 로컬의 Git 저장소
    + remote : GitHub 등의 외부 서버의 Git 원격 저장소
    + commit : 특정 상태를 기록한 버전(snapshot)
        * **의미 있는 변화**에 대한 기록
    + 브랜칭과 머징 : Git은 브랜치로 여러 작업을 동시에 진행하고 합치면서 충돌 해결까지.
        * branch : 또 다른 작업공간 기록
            - origin : 원격저장소 기본 이름
            - main : 저장소의 첫 브랜치
            - 클론할 때는 origin/HEAD이 커밋위치가 된다.
        * merge : 병합. 브랜치의 작업 내용을 다른 브랜치에 적용
    + 작업트리 :
        * 저장소를 보는 나의 현재 시점.
        * 소스코드, 빌드파일, 단위테스트 등 모든 프로젝트 파일을 갖는다.
        * 저장소와 헷갈리면 곤란하다.
        * Git에 자신의 프로젝트 저장소에 초기화하도록 요청하거나 기존의 프로젝트에서 복제하여 가져옴
    + checkout : 내 작업 트리를 저장소의 특정 시점과 일치하도록 변경하는 작업
    + push : 로컬의 저장 이력을 리모트로 반영
    + pull : 리모트의 변경 이력을 내 로컬에 다운로드
    + tag : 특정 커밋에 대한 태그 작성하고 기록하는 용도로 사용(공개 릴리즈나 버그 수정 등)
    + reset : 특정 커밋까지의 이력 초기화..
- 개발자 정보 입력
    + Git은 분산환경의 특징 때문에 이름과 이메일 주소를 git config로 설정해주어야 한다.
    
6. Git 사용 예시들
- 브랜치 : `main` -(branch)-> `dev`(작업) -(merge)-> tag: ver1.0 `main` // `dev`(작업 이어서 진행) -(merge)-> tag: ver 2.0 `main` // 각 main -(DevOps)-> Xcode Cloud
- 풀리퀘 : 1 -(pull)-> 작업 -(PR 승인)-> 2 // 